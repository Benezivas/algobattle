#!/usr/bin/env python3
"""Main battle script. Executes all possible types of battles, see battle --help for all options."""
from __future__ import annotations, generators
from configparser import ConfigParser
from sys import stderr
import os
import logging
from argparse import ArgumentParser, Namespace
import datetime as dt
from pathlib import Path

import algobattle
from algobattle.match import Match
from algobattle.util import get_matching_file, import_problem_from_path, NestedHelp
from algobattle.docker import measure_runtime_overhead, DockerConfig
from algobattle.ui import Ui
from algobattle.battle_styles import battle_styles, get_battle_style


def setup_logging(logging_path: Path, verbose_logging: bool, silent: bool):
    """Creates and returns a parent logger.

    Parameters
    ----------
    logging_path : Path
        Path to folder where the logfile should be stored at.
    verbose_logging : bool
        Flag indicating whether to include debug messages in the output
    silent : bool
        Flag indicating whether not to pipe the logging output to stderr.

    Returns
    -------
    Logger
        The Logger object.
    """
    common_logging_level = logging.INFO

    if verbose_logging:
        common_logging_level = logging.DEBUG

    logging_path.mkdir(parents=True, exist_ok=True)

    _now = dt.datetime.now()

    sep = ":" if os.name == "posix" else "-"
    current_timestamp = (f"{_now.year:04d}-{_now.month:02d}-{_now.day:02d}_"
                         f"{_now.hour:02d}{sep}{_now.minute:02d}{sep}{_now.second:02d}")
    logging_path /= current_timestamp + ".log"

    logging.basicConfig(
        handlers=[logging.FileHandler(logging_path, "w", "utf-8")],
        level=common_logging_level,
        format="%(asctime)s %(levelname)s: %(message)s",
        datefmt="%H:%M:%S",
    )

    logger = logging.getLogger("algobattle")

    if not silent:
        # Pipe logging out to console
        _consolehandler = logging.StreamHandler(stream=stderr)
        _consolehandler.setLevel(common_logging_level)

        _consolehandler.setFormatter(logging.Formatter("%(message)s"))

        logger.addHandler(_consolehandler)

    logger.info(f"You can find the log files for this run in {logging_path}")
    return logger


battle_arg_spec = {
    "rounds": {
        "type": int,
        "default": 5,
        "help": "Number of rounds that are to be fought in the battle (points are split between all rounds). Default: 5",
    },
}

help_msg = "Use 'battle --help' for more information on usage and options."


def _missing_path(path: Path, desc: str | None = None):
    start = "Path" if desc is None else f"{desc} path"
    return f"{start} '{path}' does not exist in the file system! {help_msg}"


def create_parser() -> ArgumentParser:
    """Creates a parser with the needed arguments."""
    default_logging_path = Path.home() / ".algobattle_logs"

    def resolved_path(path: str) -> Path:
        return Path(path).resolve()

    # fmt: off
    parser = ArgumentParser(add_help=False)
    parser.add_argument("--version", action="version", version=f"Algobattle version {algobattle.__version__}")
    parser.add_argument("--help", "-h", action=NestedHelp,
                        help="Battle type to display additional help for, or 'all' to display full help.")

    parser.add_argument("problem_path", type=resolved_path, help="Path to the parent directory of a problem file as argument.")
    parser.add_argument("--teams", "-t", action="extend", type=resolved_path, nargs="*",
                        help="Any number of paths that specify teams. Either by the found folder structure or a team.ini "
                        "file found there. Defaults to the problem path.")
    parser.add_argument("--config", "-c", type=resolved_path,
                        help="Path to a .ini configuration file to be used for the run. Defaults to either the 'config.ini' "
                        " file in the problem folder if it exists or the packages config.ini")
    parser.add_argument("--logging_folder", "-o", type=resolved_path, default=default_logging_path,
                        help="Specify the folder into which the log file is written to. Can either be a relative or absolute "
                        "path to folder. If nonexisting, a new folder will be created. Default: ~/.algobattle_logs/")
    parser.add_argument("--verbose", action="store_true", help="Log all debug messages.")
    parser.add_argument("--display", "-d", choices=["silent", "ui", "logs"], default="logs",
                        help="Choose display mode, silent will hide all output, logs will pipe the logs to stderr, and ui "
                        "will display a small terminal ui. Default: logs")
    parser.add_argument("--no_overhead_calculation", action="store_true",
                        help="If set, the program does not benchmark the I/O of the host system to calculate "
                        "the runtime overhead when started.")
    parser.add_argument("--no_cleanup", action="store_true", help="Don't clean up any created docker images.")
    parser.add_argument("--points", "-p", type=int, default="100",
                        help="Number of points that are to be fought for. Default: 100")
    parser.add_argument("--do_not_count_points", action="store_true", help="If set, points are not calculated for the run.")

    battle_args = parser.add_argument_group("battle arguments")
    battle_args.add_argument("--battle_type", choices=battle_styles.keys(), type=get_battle_style,
                             help="Type of battle, has to be set in the command line or config file")
    # fmt: on

    for name, kwargs in battle_arg_spec.items():
        battle_args.add_argument(f"--{name}", **(kwargs | {"default": None}))

    for name, cls in battle_styles.items():
        cls_args = battle_args.add_argument_group(name)
        for name, kwargs in cls.get_arg_spec().items():
            cls_args.add_argument(f"--{name}", **(kwargs | {"default": None}))

    return parser


def parse_args() -> Namespace:
    """Parse the command line arguments."""
    options = create_parser().parse_args()

    if not options.problem_path.exists():
        raise SystemExit(_missing_path(options.problem_path, "Problem"))

    working_dir: Path = options.problem_path
    if working_dir.is_file():
        working_dir = working_dir.parent

    if options.config is None:
        if (working_dir / "config.ini").is_file():
            options.config = options.problem_path / "config.ini"
        else:
            options.config = Path(algobattle.__file__).resolve().parent / "config" / "config.ini"
    elif not options.config.exists():
        raise SystemExit(_missing_path(options.config, "Config"))
    elif options.config.is_folder():
        options.config /= "config.ini"

    if options.teams is None:
        options.teams = [working_dir]

    return options


def parse_config(options: Namespace) -> Namespace:
    """Gets the config file from the provided options and parses it.

    Parameters
    ----------
    options : Namespace
        Options namespace as generated from `parse_args()`.

    Returns
    -------
    Namespace
        A new, cleaned up, Namespace containing the combined options.

    Raises
    ------
    SystemExit
        If no battle type is chosen or an invalid choice was made.
    """
    config = ConfigParser()
    config.read(options.config)
    battle_options = Namespace()

    if options.battle_type is not None:
        battle_type = options.battle_type
    elif "battle" in config and "battle_type" in config["battle"]:
        type_str = config["battle"]["battle_type"]
        try:
            battle_type = get_battle_style(type_str)
        except ValueError:
            styles = ", ".join(f"'{battle_styles.keys()}'")
            raise SystemExit(f"The config file contains an invalid battle type '{type_str}', choose one of {styles}.")
    else:
        raise SystemExit(f"The battle type was not specified in the command line or the config file! {help_msg}")
    battle_options.battle_style = battle_type
    battle_type = battle_type.name

    arg_specs = [("battle", battle_arg_spec), (battle_type, battle_styles[battle_type].get_arg_spec())]
    for spec_name, spec in arg_specs:
        for name, kwargs in spec.items():
            if getattr(options, name) is not None:
                setattr(battle_options, name, options.name)
            elif spec_name in config and name in config[spec_name]:
                setattr(battle_options, name, kwargs["type"](config[spec_name][name]))
            else:
                setattr(battle_options, name, kwargs["default"])
    if "docker_config" in config:
        kwargs = {
            "cpus": config["docker_config"].getint("cpus", None),
            "timeout_build": config["docker_config"].getfloat("timeout_build", None),
            "cache_containers": config["docker_config"].getboolean("cache_containers", True),
        }
        for role in ("generator", "solver"):
            kwargs[f"timeout_{role}"] = config["docker_config"].getfloat(f"timeout_{role}", None)
            kwargs[f"space_{role}"] = config["docker_config"].getint(f"space_{role}", None)
    else:
        kwargs = {}

    battle_options.docker_config = DockerConfig(**kwargs)

    return battle_options


def parse_team_info(teams: list[Path]) -> list[tuple[str, Path, Path]]:     # noqa: C901
    """Parses team info from the list of paths.

    Parameters
    ----------
    teams : list[Path]
        List of paths pointing to `team.ini` files, their parent folders, or folders with `generator` and `solver` subfolders.

    Returns
    -------
    list[tuple[str, Path, Path]]
        List of `(name, generator_path, solver_path)`

    Raises
    ------
    SystemExit
        If the specified paths don't exist in the file system.
    """
    team_info: list[tuple[str, Path, Path]] = []
    for path in teams:
        try:
            path = get_matching_file(path.resolve(), "team.ini")
        except RuntimeError:
            raise SystemExit(_missing_path(path, "Team info"))
        except ValueError:
            team_info.append((path.name, path / "generator", path / "solver"))
            continue

        config = ConfigParser()
        try:
            config.read(path)
        except Exception as e:
            logger.warning(f"Team config file '{path}' can't be parsed correctly, removing them from the battle.\nError: {e}")
            continue
        if "team" not in config:
            logger.warning(f"Team config file '{path}' does not contain a 'team' section, removing the team from the battle.")
            continue
        config = config["team"]
        name = config.get("name", path.name)
        generator = config.get("generator", "generator")
        solver = config.get("solver", "solver")
        team_info.append((name, (path / generator).resolve(), (path / solver).resolve()))

    for name, gen_path, sol_path in team_info:
        for role, path in [("generator", gen_path), ("solver", sol_path)]:
            if not path.exists:
                raise SystemExit(_missing_path(path, f"{name}'s {role}"))

    return team_info


if __name__ == "__main__":  # noqa: C901
    try:
        options = parse_args()
        logger = setup_logging(options.logging_folder, options.verbose, options.display != "logs")
        config = parse_config(options)

        try:
            problem = import_problem_from_path(options.problem_path)
        except ValueError:
            raise SystemExit(f"Could not import the problem! {help_msg}")

        logger.debug(f"Options for this run: {options}")

        if options.display == "ui":
            ui = Ui(logger, logger.getEffectiveLevel())
            ui.update("Setting up match...")
        else:
            ui = None

        if not options.no_overhead_calculation:
            logger.info("Running a benchmark to determine your machines I/O overhead to start and stop docker containers...")
            runtime_overhead = measure_runtime_overhead()
            logger.info(
                f"Maximal measured runtime overhead is at {runtime_overhead} seconds. "
                "Adding this amount to the configured runtime."
            )
            config.docker_config.add_overhead(runtime_overhead)

        team_info = parse_team_info(options.teams)
        match = Match(problem, config.docker_config, team_info, ui)
        results = match.run(**vars(config))

        if ui is not None:
            ui.restore()

        logger.info("#" * 78)
        logger.info(f"\n{results.format()}")
        if not options.do_not_count_points:
            points = results.calculate_points(options.points)
            for team, points in points.items():
                logger.info(f"Group {team} gained {points:.1f} points.")

        if not options.no_cleanup:
            match.cleanup()
        if options.display != "silent":
            print(results.format())

    except KeyboardInterrupt:
        if "logger" in locals():
            logger.critical("Received keyboard interrupt, terminating execution.")  # type: ignore
        else:
            raise SystemExit("Received keyboard interrupt, terminating execution.")
